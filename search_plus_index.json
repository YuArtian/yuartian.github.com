{"./":{"url":"./","title":"前端有道","keywords":"","body":"前端有道 天之道，损有余而补不足 人之道则不然，损不足以奉有余 孰能有余以奉天下？ 其唯有道者 "},"javascript-ji-chu/gui-fan/":{"url":"javascript-ji-chu/gui-fan/","title":"规范","keywords":"","body":"规范 重要的规范有两个：HTML的 和 JS的 HTML Living Standard Living Standard — Last Updated 22 April 2020 (英文) Living Standard — Last Updated 22 April 2020 (中文) ECMA的各版本规范 ES10 ES10 = ES2019 = ECMA-262 10th Edition (英文原版) html ES9 ES9 = ES2018 = ECMA-262 9th Edition (英文原版) html ES8 ES8 = ES2017 = ECMA-262 8th Edition (英文原版) html ES7 ES7 = ES2016 = ECMA-262 7th Edition (英文原版) html ES6 ES6 = ES2015 = ECMA-262 6th Edition (英文原版) html ES5 ES5 = ECMA-262 Edition 5.1 (英文原版) html ES5 W3C翻译 (中文版) wiki ES5 中文版 html ES3 ES3 英文版 pdf ES3 中文版 pdf "},"javascript-ji-chu/gui-fan/ming-ming-gui-ze-yu-ji-gou-ming-cheng.html":{"url":"javascript-ji-chu/gui-fan/ming-ming-gui-ze-yu-ji-gou-ming-cheng.html","title":"命名规则与机构名称","summary":"Javascript 和 JScript 和 ECMAScript 和 ECMA-262 和 TC39。。。","keywords":"","body":"命名规则与机构名称 他们之间的关系如下 ECMA（European Computer Manufacturers Association，欧洲计算机制造商协会）是一个制定计算机各种标准的国际组织，维护各种计算机相关标准 ECMA-262 是 ECMA 第262号标准，这个标准就是 ECMAScript TC39 是制定 ECMA-262 号标准的组织 ES6 是 ECMAScript 第六版 又名 ES2015 (正式的名字都是： ES+年份) Javascript 简单说就是 ECMAScript 其中一种实现，ActionScript 也是 其实 Javascript 特指 Mozilla（前身Netscape）使用的脚本语言，是 Mozilla 对 ECMAScript 的实现 JScript 则是 Microsoft 的实现 来自MDN 先从这门语言的历史谈起是有必要的。在1995 年 Netscape 一位名为 Brendan Eich 的工程师创造了 JavaScript，随后在 1996 年初，JavaScript 首先被应用于 Netscape 2 浏览器上。最初的 JavaScript 名为 LiveScript，后来，因为 Sun Microsystem 的 Java 语言兴起，被广泛使用，Netscape 出于宣传和推广的考虑，将它的名字从最初的 LiveScript 更改为 JavaScript——尽管两者之间并没有什么共同点。这便是之后混淆产生的根源 几个月后，Microsoft 随 IE 3 发布推出了一个与之基本兼容的语言 JScript。又过了几个月，Netscape 将 JavaScript 提交至 Ecma International（一个欧洲标准化组织）， ECMAScript 标准第一版便在 1997 年诞生了，随后在 1999 年以 ECMAScript 第三版的形式进行了更新，从那之后这个标准没有发生过大的改动。由于委员会在语言特性的讨论上发生分歧，ECMAScript 第四版尚未推出便被废除，但随后于 2009 年 12 月发布的 ECMAScript 第五版引入了第四版草案加入的许多特性。第六版标准已经于 2015 年 6 月发布。 "},"javascript-ji-chu/untitled/":{"url":"javascript-ji-chu/untitled/","title":"JS的执行环境","keywords":"","body":"JS的执行环境 宿主环境 JavaScript 代码的运行一般都是在一个 宿主环境 中，常见的有 浏览器 和 Node.js 宿主环境会通过 JS 引擎（比如 V8）提供 JavaScript 的执行环境 在执行代码之前，首先需要创建一个供代码解析的初试环境，初始化的内容可能包括： 一套与宿主环境相关的 API 和 内置对象 JS 引擎内核的初始化，相关的语法规则和命令等 。。。 不同的 宿主环境 和 JS引擎 所定义的初始化环境是不同的 这就是 兼容性问题 的根本所在。在最开始，各家浏览器厂商之间的标准各不相同，造成了大量的兼容性问题 这也促使了之前所说的 标准 的诞生 JavaScript 虚拟机 JavaScript引擎 也可以称作 JavaScript 虚拟机 可以简单地把 JavaScript 虚拟机理解成是一个翻译程序，将人类能够理解的编程语言JavaScript，翻译成机器能够理解的机器语言 虚拟机通过模拟实际计算机的各种功能来实现代码的执行，如模拟实际计算机的 CPU、堆栈、寄存器等，虚拟机还具有它自己的一套指令系统 所以对于 JavaScript 代码来说，V8 就是它的整个世界，当 V8 执行 JavaScript 代码时，你并不需要担心现实中不同操作系统的差异，也不需要担心不同体系结构计算机的差异，你只需要按照虚拟机的规范写好代码就可以了 V8 V8 是JavaScript 虚拟机的一种 V8 是 JavaScript 的实现，在学习 V8 工作原理时，需要格外关注 JavaScript 这些独特的设计思想和特性背后的实现 比如，为了实现函数是一等公民的特性，JavaScript 采取了基于对象的策略；再比如为了实现原型继承，V8 为每个对象引入了 __proto__ 属性 后面的编译原理都将以 V8 的基础 主流的JS引擎 Safari / JavaScriptCore（Apple） Firefox / SpiderMonkey（Mozilla） Chrome / V8（Google） "},"javascript-ji-chu/untitled/dui-he-zhan.html":{"url":"javascript-ji-chu/untitled/dui-he-zhan.html","title":"堆和栈","keywords":"","body":"堆和栈 function add(x, y) { var z = x+y return z } console.log(add(1, 2)) "},"javascript-ji-chu/bian-yi-yuan-li/":{"url":"javascript-ji-chu/bian-yi-yuan-li/","title":"编译原理","summary":"以 V8 引擎为例，说明 JS 是如何从 源码 到 执行的","keywords":"","body":"编译原理 总览 JS 引擎是用来执行 JS 代码的。那到底代码是如何被执行的呢，JS引擎又是如何工作的呢 以 Chrome V8 引擎 为例子，它的工作流程图大致如下： TL;DR V8 执行一段 JavaScript 代码所经历的主要流程了，这包括了： 初始化基础环境 解析源码生成 AST 和作用域 依据 AST 和作用域生成字节码 解释执行字节码 监听热点代码 优化热点代码为二进制的机器代码 反优化生成的二进制机器代码 "},"javascript-ji-chu/bian-yi-yuan-li/jit.html":{"url":"javascript-ji-chu/bian-yi-yuan-li/jit.html","title":"JIT","keywords":"","body":"JIT 计算机执行高级语言的两种基本的方式：解释执行 和 编译执行 解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快 但是 V8 混合使用编译器和解释器，这个技术称为 JIT（Just In Time） 在 启动过程 中 采用了解释执行的策略 在 解释执行过程 中 如果某段代码的执行频率超过一个值，那么 V8 就会采用 优化编译器 将其编译成执行效率更加高效的机器代码 充分地利用解释执行和编译执行的优点，规避其缺点 解释器（Ignition）和 优化编译器（Turbofan） 解释执行 先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，最后直接输出结果 编译执行 采用这种方式时，也需要先将源代码转换为中间代码 然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了 还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码 "},"javascript-ji-chu/bian-yi-yuan-li/chu-shi-hua-ji-chu-huan-jing.html":{"url":"javascript-ji-chu/bian-yi-yuan-li/chu-shi-hua-ji-chu-huan-jing.html","title":"初始化基础环境","keywords":"","body":"初始化基础环境 在 V8 启动执行 JavaScript 之前，它还需要准备执行 JavaScript 时所需要的一些基础环境 这些基础环境包括了 \"堆空间\" \"栈空间\" \"全局执行上下文\" \"全局作用域\" \"消息循环系统\" \"内置函数\" 等，这些内容都是在执行 JavaScript 过程中需要使用到的 JavaScript 全局执行上下文 包含了执行过程中的全局信息，比如一些内置函数，全局变量等信息 全局作用域 包含了一些全局变量，在执行过程中的数据都需要存放在内存中 而 V8 是采用了经典的堆和栈的内存管理模式，所以 V8 还需要初始化内存中的堆和栈结构 另外，想要我们的 V8 系统活起来，还需要初始化消息循环系统 消息循环系统包含了消息驱动器和消息队列，它如同 V8 的心脏，不断接受消息并决策如何处理消息 基础环境准备好之后，接下来就可以向 V8 提交要执行的 JavaScript 代码了 "},"javascript-ji-chu/bian-yi-yuan-li/ci-fa-fen-xi-fen-ci-scanner.html":{"url":"javascript-ji-chu/bian-yi-yuan-li/ci-fa-fen-xi-fen-ci-scanner.html","title":"词法分析/分词（Scanner）","keywords":"","body":"词法分析/分词（Scanner） JS 文件只是一个源码（就是一堆字符串），机器是无法执行的，引擎会调用 Scanner 对源码进行词法分析 词法分析 就是把源码的字符串分割出来，生成一系列的 token，也就是 词法单元（token） var sum = 30; // 词法分析后的结果 [ \"var\" : \"keyword\", \"sum\" : \"identifier\", \"=\" : \"assignment\", \"30\" : \"integer\", \";\" : \"eos\" (end of statement) ] "},"javascript-ji-chu/bian-yi-yuan-li/yu-fa-fen-xi-parser.html":{"url":"javascript-ji-chu/bian-yi-yuan-li/yu-fa-fen-xi-parser.html","title":"语法分析（Parser）","keywords":"","body":"语法分析（Parser） 词法分析完后，接下来的阶段就是使用 Parser 进行语法分析 语法分析的输入就是词法分析的输出 Parser 接收 词法单元流 输出 AST（抽象语法树） 词法分析和语法分析不是完全独立的，而是交错进行的 也就是说，词法分析器不会在读取所有的词法记号后再使用语法分析器来处理 在通常情况下，每取得一个词法记号，就将其送入语法分析器进行分析 语法检查 如果 JavaScript 解释器在构造语法树的时候发现有语法错误，就会抛出异常并结束整个代码块的解析 function func() { let a = 10; var a = 1; //Uncaught SyntaxError: Identifier 'a' has already been declared } 虽然函数 func 没有执行，但是在语法分析阶段就已经检查出错误，并报错了 生成 AST AST（抽象语法树）指是 源代码语法对应的树状结构 https://astexplorer.net/ 在线生成 AST 例如，var sum = 30；会对应生成如下的 AST { \"type\": \"Program\", \"start\": 0, \"end\": 13, \"body\": [ { \"type\": \"VariableDeclaration\", \"start\": 0, \"end\": 13, \"declarations\": [ { \"type\": \"VariableDeclarator\", \"start\": 4, \"end\": 12, \"id\": { \"type\": \"Identifier\", \"start\": 4, \"end\": 7, \"name\": \"sum\" }, \"init\": { \"type\": \"Literal\", \"start\": 10, \"end\": 12, \"value\": 30, \"raw\": \"30\" } } ], \"kind\": \"var\" } ], \"sourceType\": \"module\" } 语法检查 生成 AST 的同时会进行语法检查，如果源码中有语法错误，在这里就会终止 并抛出 语法错误 function func() { let a = 10; var a = 1; //Uncaught SyntaxError: Identifier 'a' has already been declared } 在上面的代码中，虽然函数 func 没有执行，但是在语法分析阶段就已经检查出错误，并报错了 这是在 预编译 阶段就检查出的错误，关于预编译阶段还有更多的例子 生成执行上下文 生成 AST 的同时也会生成该段代码的 执行上下文 关于执行上下文 和 其中包含的内容，详见 执行上下文 eager parse(全量解析) 和 lazy parse（惰性解析） 然而并不是所有 JS 都需要在初始化时就被执行，因此也不需要在初始化时就解析所有的 JS 因为编译 JS 会带来三个成本问题： **编译不必要的代码会占用 CPU 资源 在 GC 前会占用不必要的内存空间 编译后的代码会缓存在磁盘，占用磁盘空间 因此所有主流浏览器都实现了 Lazy Parse（延迟解析） 区别 Lazy Parse 会将不必要的函数（没有立即执行的函数）进行预解析 预解析只验证它跳过函数是语法有效的，并产生正确编译外部函数所需的所有信息 而 eager parse（全量解析）则在调用这个函数时才发生 所以，有如下两种解析器 eager parse（全面解析）： 用于解析立即执行的内容（包括立即执行的函数 和 顶层代码） 跳过没有立即执行的函数 构建语法树 构建函数作用域 (Scopes) 找出所有语法错误 lazy parse（惰性解析/预解析）： 用于快速扫描没有立即执行的函数 不构建语法树，会构建函数词法环境 但不设置词法环境中的变量引用（variable references）和变量申明（variable declarations） 解析速度，大约比 eager解析器 快2倍 找出限定的几种错误（没有遵守 JavaScript 的规范） 解析过程 这两种解析器在解析的过程中是交替进行解析的 let a = 0; //顶层代码 全量解析 //IIFE (function eager() {...})() //立即执行的函数 全量解析 //顶层函数 但没有立即执行 function lazy() {...} // 预解析 ... ... lazy(); // -> 调用的时候 全量解析 所有的最外层代码 和 IIFE（立即执行函数）直接使用 eager 解析 其他函数，会先进行预解析，在调用的时候才进行全面解析 下面看看一些复杂的解析情况： let f1 = function lazy() {...};//使用lazy-parsing,没有问题 ​ let f2 = function lazy() {...}() //糟糕的情况，在看到最后的括号之前已经使用了lazy parse //但遇到括号后，不得不里面又转向 eager parse，重新parse 对于嵌套函数对于解析会带来很不好的影响 function lazy_outer(){ //没有立即执行 预解析 function inner(){....} //嵌套函数 预解析 } ​ ...lazy_outer(); //执行的时候 全量解析 lazy_outer //V8 会再次解析 inner，即使 inner 已经被解析了一次 嵌套函数 inner 会被预解析两次 预解析与闭包问题 除了检查语法错误之外，预解析器另外的一个重要的功能就是检查函数内部是否引用了外部变量 如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题 function foo() { var a = 0 } function foo() { var a = 0 return function inner() { return a++ } } 第一个函数： 变量 a 在栈上，当解析 foo函数的时候，预解析没有发现内部函数，变量 a 就只会在栈上，当foo函数的执行上下文销毁的时候 a变量也会销毁 第二个函数：变量a同时在栈和堆上，当解析 foo函数的时候，预解析有发现内部函数引用外部变量 a ， 这时候就会把 a 复制 到堆上，当父函数执行到 a 的赋值语句时，会同时修改 栈和堆上的变量 a 的值, 父函数销毁的时候也只会销毁栈上的变量 a，堆上的变量 a 保留。 最后当内部函数执行完后，堆上的变量a就没有再被引用，就会被垃圾回收掉 预解析与字节码 之前 V8 没有字节码，直接将 源码 编译成 二进制的机器码 但是，依然有预解析 和 全量解析 的机制在 "},"javascript-ji-chu/ji-ben-lei-xing/":{"url":"javascript-ji-chu/ji-ben-lei-xing/","title":"基本类型","keywords":"","body":"基本类型 原始类型 (primitive) 原始类的数据，是指值本身无法被改变，比如 JavaScript 中的字符串就是原始类型，如果你修改了 JavaScript 中字符串的值，那么 V8 会返回给你一个新的字符串，原始字符串并没有被改变，我们称这些类型的值为 \"原始值\" JavaScript 中的原始值主要包括 null、undefined、boolean、number、string、bigint、symbol 这七种 "},"javascript-ji-chu/ji-ben-lei-xing/string.html":{"url":"javascript-ji-chu/ji-ben-lei-xing/string.html","title":"String","keywords":"","body":"String String.raw() 该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串 通常用于模板字符串的处理 String 查找 indexOf()：返回索引，找不到返回 -1 includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部 实现 includes 方法 String.prototype.repeat() repeat方法返回一个新字符串，表示将原字符串重复n次 String.prototype.padStart()/padEnd() 如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全 'x'.padStart(5, 'ab') // 'ababx' 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' 'x'.padEnd(4, 'ab') // 'xaba' 为数值补全指定位数 生成 10 位的数值字符串： '1'.padStart(10, '0') // \"0000000001\" '12'.padStart(10, '0') // \"0000000012\" '123456'.padStart(10, '0') // \"0000123456\" 提示字符串格式 '12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\" '09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" String.prototype.matchAll() 返回一个正则表达式在当前字符串的所有匹配 String.prototype.trim()/trimStrart()/trimEnd() "},"javascript-ji-chu/ji-ben-lei-xing/symbol.html":{"url":"javascript-ji-chu/ji-ben-lei-xing/symbol.html","title":"Symbol","keywords":"","body":"Symbol 目的 ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因 用法 Symbol 值通过 Symbol函数生成 toString Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分 let s = Symbol(); let s1 = Symbol('foo'); let s2 = Symbol('bar'); s1 // Symbol(foo) s2 // Symbol(bar) s1.toString() // \"Symbol(foo)\" s2.toString() // \"Symbol(bar)\" 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值 const obj = { toString() { return 'abc'; } }; const sym = Symbol(obj); sym // Symbol(abc) Symbol 值不能与其他类型的值进行运算，会报错 Symbol 不能 new 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型 Symbol.prototype.description 创建 Symbol 的时候，可以添加一个描述 读取这个描述可以显示的调用 toString 方法 也可以比较快捷的使用 ES2019 的 description 属性 const sym = Symbol('foo'); sym.description // \"foo\" 作为属性名的 Symbol Symbol 作为属性名时，不能使用 点 运算符 遍历 Symbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中 也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回 Object.getOwnPropertySymbol 可以返回所有 Symbol 属性的值 Reflect.ownKeys 可以返回所有类型的键名 重用 Symbol.for() 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局 let s1 = Symbol.for('foo'); let s2 = Symbol.for('foo'); s1 === s2 // true "},"javascript-ji-chu/dui-xiang.html":{"url":"javascript-ji-chu/dui-xiang.html","title":"对象","keywords":"","body":"对象 "},"javascript-ji-chu/han-shu/":{"url":"javascript-ji-chu/han-shu/","title":"函数","keywords":"","body":"函数 函数是一等公民 JavaScript 中的函数非常灵活，其根本原因在于 JavaScript 中的函数就是一种特殊的对象，我们把 JavaScript 中的函数称为一等公民 (First Class Function) 函数可以赋值给一个变量，也可以作为函数的参数，还可以作为函数的返回值。如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民 函数的本质 在 JavaScript 中，函数是一种特殊的对象 函数作为一个对象，它有自己的属性和值，所以函数关联了基础的属性和值 函数之所以称为特殊的对象，这个特殊的地方是函数可以 被调用 一个函数被调用时，它还需要关联相关的 执行上下文 可调用 为函数对象添加了两个隐藏属性 name 和 code name 标识函数名，匿名函数为 anonymous code 表示函数代码，以字符串的形式存储在内存中 当执行到一个函数调用语句时，V8 便会从函数对象中取出 code 属性值，也就是函数代码，然后再解释执行这段函数代码，这就实现了函数可以调用的特性 可继承 函数提供 prototype 属性，用于实现基于原型链的继承 函数的定义 函数声明 function name () {} 函数声明属于 语句，语句会被提升而且函数是整体提升 函数声明一定要有函数名，否则会报错 函数表达式 var foo = function (){ console.log('foo') } 函数表达式属于 表达式，function 函数部分 不会参与 变量提升 Function 构造函数 new Function ([arg1[, arg2[, ...argN]],] functionBody) 箭头函数 ES6 允许使用“箭头”（=>）定义函数 函数声明与函数表达式 foo() // 'foo' function foo(){ console.log('foo') } foo() //Uncaught TypeError: foo is not a function var foo = function (){ console.log('foo') } 当执行这段代码的时候，V8 在编译阶段会先查找声明语句，你可以把这段代码拆分为下面两行代码： var foo = undefined foo = function (){ console.log('foo') } 第一行是声明语句，所以 V8 在解析阶段，就会在作用域中创建该对象，并将该对象设置为 undefined 第二行是函数表达式，在编译阶段，V8 并不会处理 函数表达式 所以也就不会将该函数表达式提升到作用域中了 那么在函数表达式之前调用该函数 foo，此时的 foo 只是指向了 undefined，所以就相当于调用一个 undefined，而 undefined 只是一个原生对象，并不是函数，所以当然会报错了 函数的参数 默认值 默认值配合结构的写法 // 写法一 function m1({x = 0, y = 0} = {}) { return [x, y]; } // 写法二 function m2({x, y} = { x: 0, y: 0 }) { return [x, y]; } // 函数没有参数的情况 m1() // [0, 0] m2() // [0, 0] // x 和 y 都有值的情况 m1({x: 3, y: 8}) // [3, 8] m2({x: 3, y: 8}) // [3, 8] // x 有值，y 无值的情况 m1({x: 3}) // [3, 0] m2({x: 3}) // [3, undefined] // x 和 y 都无值的情况 m1({}) // [0, 0]; m2({}) // [undefined, undefined] m1({z: 3}) // [0, 0] m2({z: 3}) // [undefined, undefined] null 不会触发参数默认值 function foo(x = 5, y = 6) { console.log(x, y); } foo(undefined, null) // 5 null 上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值 函数 length 属性不再准确 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数 也就是说，指定了默认值后，length属性将失真 (function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).length // 2 参数作用域 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域 等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的 var x = 1; function f(x, y = x) { console.log(y); } f(2) // 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。 let x = 1; function f(y = x) { let x = 2; console.log(y); } f() // 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。 如果此时，全局变量x不存在，就会报错 "},"javascript-ji-chu/han-shu/jian-tou-han-shu.html":{"url":"javascript-ji-chu/han-shu/jian-tou-han-shu.html","title":"箭头函数","keywords":"","body":"箭头函数 ES6 允许使用“箭头”（=>）定义函数 箭头函数有几个使用注意点 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 this对象的指向是可变的，但是在箭头函数中没有 this， 导致内部的this就是外层代码块的this 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 也是因为没有 this 不能使用 call，apply，bind。还是因为没有 this 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替 不可以使用yield命令，因此箭头函数不能用作 Generator 函数 箭头函数和this指向 箭头函数中是没有 this 的，这导致它内部的 this 就是 定义时所在的对象 setTimeout 中的 this setTimeout 中的回调函数是在全局环境下执行的，所以 this 的值，指向全局对象 window 可以用箭头函数修复这个问题 let obj = { a: 'a', getThis: function(){ setTimeout(() => { console.log('getThis', this) },0) } } obj.getThis() // obj 封装回调函数 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数 var handler = { id: '123456', init: function() { document.addEventListener('click', event => this.doSomething(event.type), false); }, doSomething: function(type) { console.log('Handling ' + type + ' for ' + this.id); } }; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象 否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象 不适用的情况 定义对象的方法 const cat = { lives: 9, jumps: () => { this.lives--; } } "},"javascript-ji-chu/han-shu/iife.html":{"url":"javascript-ji-chu/han-shu/iife.html","title":"IIFE","keywords":"","body":"IIFE 立即调用函数表达式 JavaScript 中有一个圆括号运算符，圆括号里面可以放一个表达式，比如下面的代码： (a = 3) 括号里面是一个表达式，整个语句也是一个表达式，最终输出 3 如果在小括号里面放上一段函数的定义，如下所示： (function () { //statements}) 因为小括号之间存放的必须是表达式，所以如果在小括号里面定义一个函数，那么 V8 就会把这个函数看成是函数表达式，执行时它会返回一个函数对象 存放在括号里面的函数便是一个函数表达式，它会返回一个函数对象，如果我直接在表达式后面加上调用的括号，这就称为 立即调用函数表达式（IIFE） (function () { //statements })() 作用 因为函数立即表达式也是一个表达式，所以 V8 在编译阶段，并不会为该表达式创建函数对象 这样的一个好处就是不会污染环境，函数和函数内部的变量都不会被其他部分的代码访问到 在 ES6 之前，JavaScript 中没有私有作用域的概念，如果在多人开发的项目中，你模块中的变量可能覆盖掉别人的变量，所以使用函数立即表达式就可以将我们内部变量封装起来，避免了相互之间的变量污染 另外，因为函数立即表达式是立即执行的，所以将一个函数立即表达式赋给一个变量时，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。如下所示： var a = (function () { return 1 })() "},"javascript-ji-chu/han-shu/wei-tiao-yong-he-wei-di-gui.html":{"url":"javascript-ji-chu/han-shu/wei-tiao-yong-he-wei-di-gui.html","title":"尾调用和尾递归","keywords":"","body":"尾调用和尾递归 尾调用（Tail Call） 尾调用是指 a 函数的最后一步是调用 b 函数，而且没有其他操作，b 函数中也没有引用到 a 函数中的变量 尾调用之所以与其他调用不同，就在于它的特殊的调用位置 函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack） 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了 也就是说，尾调用中，只有一个调用帧 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化” 支持 尾调用优化 的浏览器还不够多，貌似只有 Safari 尾递归 函数调用自身，称为递归。如果尾调用自身，就称为尾递归 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow） 但对于尾递归来说，由于可以进行 尾调用优化，只存在一个调用帧 所以永远不会发生 栈溢出 错误 ES6 严格模式下，尾递归优化才生效 递归函数改写 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身 做到这一点的方法，就是把所有用到的内部变量改写成函数的参数 有两种方法可以改写现有的递归函数 function Fibonacci (n) { if ( n 增加函数 function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total); } function factorial(n) { return tailFactorial(n, 1); } factorial(5) // 120 ES6 函数默认值 function factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5) // 120 严格模式 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数 尾递归优化实现 没有尾递归的时候，可以用 循环 来解决递归爆栈的问题 sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数 function sum(x, y) { if (y > 0) { return sum(x + 1, y - 1); } else { return x; } } sum(1, 100000) // Uncaught RangeError: Maximum call stack size exceeded(…) 蹦床函数（trampoline） function trampoline(f) { while (f && f instanceof Function) { f = f(); } return f; } // sum 也需要更改 function sum(x, y) { if (y > 0) { return sum.bind(null, x + 1, y - 1); } else { return x; } } trampoline(sum(1, 100000)) // 100001 真正的尾递归优化 function tco(f) { var value; var active = false; var accumulated = []; return function accumulator() { accumulated.push(arguments); if (!active) { active = true; while (accumulated.length) { value = f.apply(this, accumulated.shift()); } active = false; return value; } }; } var sum = tco(function(x, y) { if (y > 0) { return sum(x + 1, y - 1) } else { return x } }); sum(1, 100000) // 100001 "},"javascript-ji-chu/ji-cheng.html":{"url":"javascript-ji-chu/ji-cheng.html","title":"继承","keywords":"","body":"继承 "},"javascript-ji-chu/set-he-map.html":{"url":"javascript-ji-chu/set-he-map.html","title":"Set 和 Map","keywords":"","body":"Set 和 Map Set 类似于数组，但是成员的值都是唯一的，没有重复的值 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化 去重 数组 [...new Set(array)] 字符串 [...new Set[string]].join('') 判定 向 Set 加入值的时候，不会发生类型转换，所以5和\"5\"是两个不同的值 Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality” 它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身 属性和方法 Set 结构的实例有以下属性 Set.prototype.constructor：构造函数，默认就是Set函数 Set.prototype.size：返回Set实例的成员总数 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员） 四个操作方法 Set.prototype.add(value)：添加某个值，返回 Set 结构本身 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员 Set.prototype.clear()：清除所有成员，没有返回值 四个遍历方法 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 keys方法、values方法、entries方法返回的都是遍历器对象，取值需要用 for...of 遍历 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致 应用 可以直接用for...of循环遍历 Set 扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 let a = new Set([1, 2, 3]); let b = new Set([4, 3, 2]); // 并集 let union = new Set([...a, ...b]); // Set {1, 2, 3, 4} // 交集 let intersect = new Set([...a].filter(x => b.has(x))); // set {2, 3} // 差集 let difference = new Set([...a].filter(x => !b.has(x))); // Set {1} WeakSet WeakSet 的成员只能是对象，而不能是其他类型的值 WeakSet 中的对象都是弱引用 WeakSet 没有size属性，没有办法遍历它的成员 WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了 WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏 Map JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构 WeakMap "},"javascript-ji-chu/kuo-zhan-yun-suan-fu.html":{"url":"javascript-ji-chu/kuo-zhan-yun-suan-fu.html","title":"扩展运算符","keywords":"","body":"扩展运算符 扩展运算符（...）内部使用for...of循环 "},"javascript-ji-chu/proxy.html":{"url":"javascript-ji-chu/proxy.html","title":"Proxy","keywords":"","body":"Proxy 在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写 语法 var proxy = new Proxy(target, handler); var obj = new Proxy({}, { get: function (target, propKey, receiver) { console.log(`getting ${propKey}!`); return Reflect.get(target, propKey, receiver); }, set: function (target, propKey, value, receiver) { console.log(`setting ${propKey}!`); return Reflect.set(target, propKey, value, receiver); } }); "}}